# Form implementation generated from reading ui file 'e-mall-main-win.ui'
#
# Created by: PyQt6 UI code generator 6.7.0
#
# WARNING: Any manual changes made to this file will be lost when pyuic6 is
# run again.  Do not edit this file unless you know what you are doing.

import time
import config
from PyQt6.QtWidgets import QApplication, QMainWindow, QWidget
from PyQt6 import QtCore, QtGui, QtWidgets
from PyQt6 import uic
from PyQt6.QtGui import QMovie
from PyQt6.QtWidgets import QGraphicsOpacityEffect
from PyQt6.QtCore import QPropertyAnimation, QRect, QTimer
from PyQt6 import QtCore, QtGui, QtWidgets
from PyQt6.QtWidgets import QApplication, QMainWindow, QWidget, QFrame, QLabel, QPushButton, QGridLayout
from PyQt6.QtCore import QPropertyAnimation, QEasingCurve, Qt, pyqtSignal, QTimer
from utilities import *
from PyQt6.QtWidgets import QApplication, QMainWindow, QWidget, QVBoxLayout, QLabel, QSizePolicy, QFrame, QPushButton
from PyQt6 import uic, QtGui
from PyQt6.QtCharts import QChart, QChartView, QLineSeries, QValueAxis
from PyQt6.QtGui import QPainter
from PyQt6.QtCore import Qt, QTimer, QRect, pyqtSignal, QPropertyAnimation
import traceback


class ClickableLabel(QLabel):
    clicked = pyqtSignal()

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.setStyleSheet("cursor: pointer;")

    def mousePressEvent(self, event):
        if self.rect().contains(event.pos()):  # Ensure the click is within the label's rectangle
            self.clicked.emit()
        super().mousePressEvent(event)


def disconnect_button_signals(button):
    try:
        button.clicked.disconnect()
    except TypeError:
        pass  # If the button has no signals connected, pass


def update_product_stock(product_id, new_stock_quantity, mall_id):
    config.product_stock_quantity = new_stock_quantity
    update_product_stock_query = f"UPDATE `products` SET `quantity_in_stock` = %s WHERE `mall_id` = %s AND `product_id` = %s"
    my_cur.execute(update_product_stock_query, (new_stock_quantity, mall_id, product_id))

    select_query = """SELECT product_id, product_name, product_image, product_price, quantity_in_stock, description FROM products WHERE mall_id = %s"""
    my_cur.execute(select_query, (mall_id,))
    products = my_cur.fetchall()
    print(products)
    print(type(products))

    # Convert Decimal objects to float in the fetched data
    products_list = []
    for product in products:
        product_dict = {
            'product_id': product[0],
            'product_name': product[1],
            'product_image': product[2],
            'product_price': float(product[3]),  # Convert Decimal to float
            'quantity_in_stock': product[4],
            'description': product[5]
        }
        products_list.append(product_dict)

    # Now serialize the list of dictionaries
    products_json = json.dumps(products_list)
    print(products_json)

    # Update the mall_products column in the malls table
    insert_query = """UPDATE malls SET mall_products = %s WHERE mall_id = %s"""
    my_cur.execute(insert_query, (products_json, mall_id))
    conn_obj.commit()

    conn_obj.commit()
    # This function should be implemented to update the product's stock quantity in your database
    pass


def get_query_for_metric(metric):
    queries = {
        'average_order_value': """
            SELECT AVG(amount) AS average_order_value
            FROM purchases
            WHERE mall_id = %s
        """,
        'total_profit': """
            SELECT SUM(amount) AS total_profit
            FROM purchases
            WHERE mall_id = %s
        """,
        'total_order_items': """
            SELECT COUNT(*) AS total_order_items
            FROM purchases
            WHERE mall_id = %s
        """,
        'total_order_units': """
            SELECT SUM(quantity) AS total_order_units
            FROM purchases
            WHERE mall_id = %s
        """,
        'total_store_visits': """
            SELECT COUNT(*) AS total_store_visits
            FROM visits
            WHERE mall_id = %s
        """,
        "order_conversion_rate": """
            SELECT AVG(conversion_rate) AS order_conversion_rate
            FROM metrics
            WHERE mall_id = %s
        """
    }
    return queries.get(metric)


def fetch_data(metric):
    mall_id = config.mall_id  # Assuming mall_id is stored in your config
    data = []

    # Define the queries based on the metric
    queries = {
        'average_order_value': """
            SELECT DATE(purchase_date) AS period, AVG(amount) AS average_order_value
            FROM purchases
            WHERE mall_id = %s
            GROUP BY DATE(purchase_date)
            ORDER BY DATE(purchase_date)
        """,
        'total_profit': """
            SELECT DATE(purchase_date) AS period, SUM(amount) AS total_profit
            FROM purchases
            WHERE mall_id = %s
            GROUP BY DATE(purchase_date)
            ORDER BY DATE(purchase_date)
        """,
        'total_order_items': """
            SELECT DATE(purchase_date) AS period, COUNT(*) AS total_order_items
            FROM purchases
            WHERE mall_id = %s
            GROUP BY DATE(purchase_date)
            ORDER BY DATE(purchase_date)
        """,
        'total_order_units': """
            SELECT DATE(purchase_date) AS period, SUM(quantity) AS total_order_units
            FROM purchases
            WHERE mall_id = %s
            GROUP BY DATE(purchase_date)
            ORDER BY DATE(purchase_date)
        """,
        'total_store_visits': """
            SELECT DATE(visit_date) AS period, COUNT(*) AS total_store_visits
            FROM visits
            WHERE mall_id = %s
            GROUP BY DATE(visit_date)
            ORDER BY DATE(visit_date)
        """,
        'order_conversion_rate': """
            SELECT DATE(period) AS period, conversion_rate AS order_conversion_rate
            FROM metrics
            WHERE mall_id = %s
            GROUP BY DATE(period)
            ORDER BY DATE(period)
        """
    }

    query = queries.get(metric)
    if query:
        my_cur.execute(query, (mall_id,))
        result = my_cur.fetchall()
        data = [(i, float(row[1])) for i, row in enumerate(result)]

    print(data)
    return data


def fetch_all_data():
    metrics = ['average_order_value', 'total_profit', 'total_order_items', 'total_order_units',
               'total_store_visits', "order_conversion_rate"]
    data = {}

    for metric in metrics:
        query = get_query_for_metric(metric)
        if query:
            my_cur.execute(query, (config.mall_id,))
            result = my_cur.fetchone()
            print(f"Query result for {metric}: {result}")  # Debugging line
            if result and len(result) > 0:
                data[metric] = result[0]  # Use the correct index based on your query
            else:
                data[metric] = 'N/A'

    return data


def validate_address(address):
    if not address:
        return False, "Address cannot be empty."

    # Simple regex to check for at least one number and one letter
    if not re.match(r'^(?=.*\d)(?=.*[A-Za-z])', address):
        return False, "Address must contain both letters and numbers."

    return True, "Address seems valid."


class MainApp(QMainWindow):

    def __init__(self):
        super().__init__()
        uic.loadUi('emall.ui', self)
        self.connect_signals()
        self.connect_all()
        self.loading_label.hide()
        self.sign_in_page.setCurrentIndex(0)

    def connect_signals(self):
        for child in self.findChildren(QtWidgets.QPushButton):
            child.setEnabled(True)
        self.continue_button.clicked.connect(self.handle_login)
        self.continue_button_3.clicked.connect(self.enter_sign_up)
        self.submit_button.clicked.connect(self.handle_sign_up)
        self.back_to_sign_in_button.clicked.connect(self.go_to_sign_in)
        self.back_to_sign_up_button.clicked.connect(self.go_to_sign_up)
        self.submit_seller_application.clicked.connect(self.handle_seller_signup)
        self.create_store_submit_button.clicked.connect(self.handle_create_mall)
        self.withdraw_money_button.clicked.connect(self.withdraw_money)

    def show_notification_message(self, message):
        # Set the initial geometry and text for the notification label
        self.main_app_notif_label.setGeometry(QtCore.QRect(230, -30, 360, 30))
        self.main_app_notif_label.setText(message)
        self.main_app_notif_label.show()

        # Create and configure the animation for moving the label down
        self.animation_down = QPropertyAnimation(self.notification_label, b"geometry")
        self.animation_down.setDuration(500)  # Duration for moving down
        self.animation_down.setStartValue(QtCore.QRect(230, -30, 360, 30))
        self.animation_down.setEndValue(QtCore.QRect(230, 10, 360, 30))

        # Create and configure the animation for moving the label up
        self.animation_up = QPropertyAnimation(self.notification_label, b"geometry")
        self.animation_up.setDuration(500)  # Duration for moving up
        self.animation_up.setStartValue(QtCore.QRect(230, 10, 360, 30))
        self.animation_up.setEndValue(QtCore.QRect(230, -30, 360, 30))

        # Set up a QTimer to start the "move up" animation after 3 seconds
        self.timer = QTimer()
        self.timer.setSingleShot(True)
        self.timer.timeout.connect(self.start_animation_up)
        self.timer.start(3000)  # Wait for 3 seconds

        # Start the "move down" animation
        self.animation_down.start()

    def start_animation_up(self):
        # Start the "move up" animation
        self.animation_up.start()

    def go_to_sign_in(self):
        self.sign_in_page.setCurrentIndex(0)

    def go_to_sign_up(self):
        self.sign_in_page.setCurrentIndex(1)

    def handle_login(self):
        username_or_email = self.user_name_email_line.text()
        password = self.password_edit.text()

        user = login(username_or_email, password)

        if user:
            # Start the loading process
            self.start_loading(f'Processing')

            # Delay logic using QTimer for a fake loading experience
            QTimer.singleShot(5000, lambda: self.process_user_login(user))  # 5 seconds delay before processing login

        else:
            self.show_notification_message('Invalid username or password')
            print('Invalid username or password')

    def process_user_login(self, user):
        config.username = user[1]
        config.email = user[2]
        config.password = user[3]
        config.role = user[4]
        config.account_balance = user[5]
        config.user_id = user[0]
        config.full_name = user[6]
        config.gov_id = user[7]
        config.bank_acct_number = user[8]
        self.clear_inputs()

        # Based on role, redirect to the appropriate window
        if config.role == 'customer':
            self.app_stacked_widget.setCurrentIndex(1)
            self.show_notification_message(f'Welcome, {config.username}!')
            self.main_stacked_widget.setCurrentIndex(0)
            self.home_page_widget.setCurrentIndex(0)
            self.fetch_malls_data()
            self.welcome_username_label.setText(f'Welcome, {config.username}!!')
            self.account_balance_label.setText(str(config.account_balance))

        elif config.role == 'seller':
            config.mall_id = user[9]
            print('seller')
            self.app_stacked_widget.setCurrentIndex(2)
            self.show_notification_message(f'Welcome, seller {config.username}!')
            self.welcome_username_label_2.setText(f'Welcome, seller {config.username}!!')
            self.account_balance_label_2.setText(str(config.account_balance))

            # Create chart and series
            self.chart_frame = self.findChild(QWidget, 'graph_frame')
            self.chart = QChart()
            self.chart_view = QChartView(self.chart)
            self.chart_view.setRenderHint(QPainter.RenderHint.Antialiasing)

            # Set layout for the frame and add the chart view
            layout = QVBoxLayout(self.chart_frame)
            layout.addWidget(self.chart_view)
            self.chart_frame.setLayout(layout)

            # Initialize the app by setting default chart data
            self.initialize_app()

        else:
            self.show_notification_message('An unexpected error occurred')

    def start_loading(self, loading_message):
        """
        This function shows the loading label, plays the loading GIF, and applies the fade-in animation.
        """

        # Show the label and start the GIF
        self.loading_label.show()
        simulate_loading_label(self.loading_label, final_text="All done!", load_time=5000, interval=300,
                               loading_message=loading_message, max_dots=5)        # self.loading_gif.start()


    def enter_sign_up(self):
        self.sign_in_page.setCurrentIndex(1)

    def clear_inputs(self):
        self.user_name_email_line.clear()
        self.password_edit.clear()

    def handle_sign_up(self):
        username = self.user_name_email_line_2.text()
        email = self.user_name_email_line_3.text()
        password = self.password_edit_2.text()
        is_seller = self.seller_check_box

        if not is_seller.isChecked():

            if not username:
                self.show_notification_message("Please enter username.")
                print("Please enter username.")
                return

            if not confirm_user_name(username):
                self.show_notification_message('username already exists')
                return

            if not is_valid_email(email):
                self.show_notification_message("Please input a valid email.")
                print("Please input a valid email.")
                return

            if not confirm_email(email):
                self.show_notification_message('email already exists')
                return

            is_valid_pass, message = is_valid_password(password)
            if not is_valid_pass:
                self.show_notification_message(message)
                return

            user_id = generate_user_id()

            user = sign_up(user_id, username, email, password)

            # Check if the user was created successfully
            if user:
                simulate_loading('Account created successfully')
                print(f'Your USER ID: {user_id}')
                self.show_notification_message(f'Account created successfully\nYour USER ID: {user_id}')
                config.user_id = user_id
                # self.clear_inputs_1()
                self.sign_in_page.setCurrentIndex(0)
            else:
                self.show_notification_message("Failed to create an account.")
                print("Failed to create an account.")
        else:
            self.show_notification_message('you are signing up as a seller')
            if not username:
                self.show_notification_message("Please enter valid username.")
                print("Please enter valid username.")
                return

            if not confirm_user_name(username):
                self.show_notification_message('username already exists')
                return

            if not is_valid_email(email):
                self.show_notification_message("Please input a valid email.")
                print("Please input a valid email.")
                return

            if not confirm_email(email):
                self.show_notification_message('email already exists')
                return

            is_valid_pass, message = is_valid_password(password)
            if not is_valid_pass:
                self.show_notification_message(message)
                return
            self.sign_in_page.setCurrentIndex(2)

    def handle_seller_signup(self):
        full_name = self.full_name_line_edit.text().title()
        gov_id = self.gov_id_number_edit.text()
        bank_num = self.bank_account_number_edit.text()

        if not full_name:
            self.show_notification_message('Please enter your full name')
            return

        if not validate_full_name(full_name):
            self.show_notification_message('Please enter both first and last name')
            return

        if not gov_id:
            self.show_notification_message('Please enter your government ID number')
            return

        if not validate_government_id(gov_id):
            self.show_notification_message('Please enter a valid government ID number')
            return

        if not bank_num:
            self.show_notification_message('Please enter your bank account number')
            return

        if not validate_bank_account_number(bank_num):
            self.show_notification_message('Please enter a valid bank account number')
            return

        user_id = generate_user_id()

        username = self.user_name_email_line_2.text()
        email = self.user_name_email_line_3.text()
        password = self.password_edit_2.text()

        user = sign_up(user_id, username, email, password, role='seller')
        register_seller(user_id, full_name, gov_id, bank_num)
        config.full_name = full_name
        config.gov_id = gov_id
        config.bank_acct_number = bank_num

        # Check if the user was created successfully
        if user:
            simulate_loading('Account created successfully')
            print(f'Your USER ID: {user_id}')
            config.user_id = user_id
            self.show_notification_message(f'Your USER ID: {user_id}')
            self.clear_inputs_1()
            self.clear_seller_inputs()
            self.app_stacked_widget.setCurrentIndex(3)


        else:
            self.show_notification_message("Failed to create an account.")
            print("Failed to create an account.")

    def clear_seller_inputs(self):
        self.full_name_line_edit.setText('')
        self.gov_id_number_edit.setText('')
        self.bank_account_number_edit.setText('')

    def connect_all(self):
        self.main_stacked_widget.setCurrentIndex(0)
        self.home_page_widget.setCurrentIndex(0)
        self.settingd_stacked_widget.setCurrentIndex(0)
        self.home_button.clicked.connect(self.go_to_home_page)
        self.profile_button.clicked.connect(self.go_to_profile_page)
        self.buy_product_button.clicked.connect(self.buy_products)
        self.clear_cart_button.clicked.connect(self.clear_cart)
        self.settings_button.clicked.connect(self.go_to_settings_page)
        self.profile_settingsbutton.clicked.connect(self.go_to_profile_settings)
        self.bank_settingsbutton.clicked.connect(self.go_to_bank_settings)
        self.save_bank_info_button.clicked.connect(self.save_bank_info_changes)
        self.deposit_money_button.clicked.connect(self.deposit_money)
        self.tandc_settingsbutton.clicked.connect(self.go_to_terms_and_conditions)
        self.back_to_settings_page_button.clicked.connect(self.go_to_settings_page)
        self.back_to_settings_page_button_2.clicked.connect(self.go_to_settings_page)
        self.back_to_settings_page_button_3.clicked.connect(self.go_to_settings_page)
        self.back_to_products_page_button_4.clicked.connect(self.go_to_products_page_seller)
        self.logout_settingsbutton.clicked.connect(self.log_out)
        self.logout_settingsbutton_2.clicked.connect(self.log_out)
        self.hamburger_menu_button.clicked.connect(self.slide_left_menu)
        self.shopping_cart_button.clicked.connect(self.show_shopping_cart_menu)
        self.back_to_malls_page_button.clicked.connect(self.go_to_malls_page)
        self.back_to_products_page_button.clicked.connect(self.go_to_products_page)
        self.menu_expanded = True
        self.cart_expanded = True
        self.count = 0
        self.notification_label.hide()
        self.welcome_username_label.setText(f'Welcome, {config.username}!!')
        self.account_balance_label.setText(str(config.account_balance))
        self.quantity_edit.setText('1')
        # Call method to populate grid layout
        self.populate_grid_layout()

    def show_notification_message(self, message):
        # Set the initial geometry and text for the notification label
        self.main_app_notif_label.setGeometry(QtCore.QRect(230, -30, 360, 30))
        self.main_app_notif_label.setText(message)
        self.main_app_notif_label.show()

        # Create and configure the animation for moving the label down
        self.animation_down = QPropertyAnimation(self.main_app_notif_label, b"geometry")
        self.animation_down.setDuration(500)  # Duration for moving down
        self.animation_down.setStartValue(QtCore.QRect(230, -30, 360, 30))
        self.animation_down.setEndValue(QtCore.QRect(230, 10, 360, 30))

        # Create and configure the animation for moving the label up
        self.animation_up = QPropertyAnimation(self.main_app_notif_label, b"geometry")
        self.animation_up.setDuration(500)  # Duration for moving up
        self.animation_up.setStartValue(QtCore.QRect(230, 10, 360, 30))
        self.animation_up.setEndValue(QtCore.QRect(230, -30, 360, 30))

        # Set up a QTimer to start the "move up" animation after 3 seconds
        self.timer = QTimer()
        self.timer.setSingleShot(True)
        self.timer.timeout.connect(self.start_animation_up)
        self.timer.start(3000)  # Wait for 3 seconds

        # Start the "move down" animation
        self.animation_down.start()

    def start_animation_up(self):
        # Start the "move up" animation
        self.animation_up.start()

    def slide_left_menu(self):
        width = self.menu_frame.width()
        if width == 131:
            new_width = 81
        else:
            new_width = 81

        self.animation = QPropertyAnimation(self.menu_frame, b"minimumWidth")
        self.animation.setDuration(500)
        self.animation.setStartValue(width)
        self.animation.setEndValue(new_width)
        self.animation.setEasingCurve(QEasingCurve.Type.InOutQuart)
        self.animation.finished.connect(self.animation_finished_menu)
        self.animation.start()

        self.hamburger_menu_button.setEnabled(False)

    def show_shopping_cart_menu(self):
        width = self.shopping_cart_frame.width()
        height = self.shopping_cart_frame.height()

        if width == 250 and height == 600:
            new_width = 0
            new_height = 0
        else:
            new_width = 250
            new_height = 600

        self.animation_width = QPropertyAnimation(self.shopping_cart_frame, b"minimumWidth")
        self.animation_height = QPropertyAnimation(self.shopping_cart_frame, b"minimumHeight")

        # Set animation properties here
        # Example:
        self.animation_width.setDuration(500)
        self.animation_width.setStartValue(width)
        self.animation_width.setEndValue(new_width)

        self.animation_height.setDuration(500)
        self.animation_height.setStartValue(height)
        self.animation_height.setEndValue(new_height)

        self.animation_width.setEasingCurve(QEasingCurve.Type.InOutQuart)
        self.animation_height.setEasingCurve(QEasingCurve.Type.InOutQuart)

        self.animation_width.finished.connect(self.animation_finished_shopping_cart)

        # Start animations
        self.animation_width.start()
        self.animation_height.start()

    def animation_finished_shopping_cart(self):
        self.cart_expanded = not self.cart_expanded
        final_width = 250 if self.cart_expanded else 0
        final_height = 600 if self.cart_expanded else 0
        self.shopping_cart_frame.setMinimumWidth(final_width)
        self.shopping_cart_frame.setMaximumWidth(final_width)
        self.shopping_cart_frame.setMinimumHeight(final_height)
        self.shopping_cart_frame.setMaximumHeight(final_height)
        self.shopping_cart_button.setEnabled(True)

    def animation_finished_menu(self):
        self.menu_expanded = not self.menu_expanded
        final_width = 131 if self.menu_expanded else 81
        self.menu_frame.setMinimumWidth(final_width)
        self.menu_frame.setMaximumWidth(final_width)
        self.hamburger_menu_button.setEnabled(True)

    def go_to_home_page(self):
        self.main_stacked_widget.setCurrentIndex(0)
        self.home_page_widget.setCurrentIndex(0)
        self.fetch_malls_data()
        self.welcome_username_label.setText(f'Welcome, {config.username}!!')
        self.account_balance_label.setText(str(config.account_balance))

    def go_to_profile_page(self):
        self.fetch_statistics = fetch_statistics()
        self.profie_username_label.setText(config.username)
        self.profile_account_balance_label.setText(str(config.account_balance))
        self.profile_role_label.setText(config.role)
        self.profile_email_label.setText(config.email)
        self.profile_uid_label.setText(config.user_id)

        self.total_purchases_label.setText(str(config.total_purchases))
        self.total_amount_spent_label.setText(str(config.total_amount_spent))
        self.total_items_bought_label.setText(str(config.total_items_bought))
        self.most_visited_mall_label.setText(config.most_visited_mall)
        self.most_bought_product_label.setText(config.most_bought_product)
        self.most_actice_day_of_the_week_label.setText(config.most_active_day_of_the_week)

        self.most_recent_purchase_product_label.setText(config.most_recent_purchase_product)
        self.most_recent_purchase_price_label.setText(str(config.most_recent_purchase_product_amount))
        self.most_recent_purchase_quantity_label.setText(str(config.most_recent_purchase_product_quantity))
        self.main_stacked_widget.setCurrentIndex(1)

    def go_to_settings_page(self):
        self.main_stacked_widget.setCurrentIndex(2)
        self.settingd_stacked_widget.setCurrentIndex(0)

    def go_to_profile_settings(self):
        self.settingd_stacked_widget.setCurrentIndex(1)
        self.profilesetting_username_line_edit.setText(config.username)
        self.profilesettings_email_line_edit.setText(config.email)
        self.profile_picture_label_2.setPixmap(QtGui.QPixmap("./images/accounticonpng.png"))
        self.save_changes_button.clicked.connect(self.save_changes)

    def save_changes(self):
        username = self.profilesetting_username_line_edit.text()
        email = self.profilesettings_email_line_edit.text()
        user_id = config.user_id

        update_account_info(username, email, user_id)
        self.show_notification_message('Account info updated')

    def save_bank_info_changes(self):
        payment_method = self.payment_method_combo_box.currentText()
        config.payment_method = payment_method
        card_number = self.card_number_edit.text()

        if not card_number.isdigit():
            self.show_notification_message('new card number is not numbers')
            print('new card number is not numbers')
            return

        if not len(card_number) == 10:
            self.show_notification_message('incomplete card number')
            print('incomplete card number')

        config.card_number = card_number
        self.show_notification_message('Bank info updated')
        print('Bank info updated')

    def deposit_money(self):
        amount = self.deposit_money_line_edit.text()

        if not amount.isdigit():
            self.show_notification_message('incorrect input')
            print('incorrect input')
            return

        if len(amount) > 8:
            self.show_notification_message('invalid amount')
            print('invalid amount')
            return

        new_balance = int(amount) + config.account_balance
        update_account_balance(new_balance, config.user_id)
        config.account_balance = new_balance
        self.account_balance_label.setText(str(new_balance))
        self.deposit_money_line_edit.setText('')
        self.show_notification_message('account balance updated!!!')
        print('account balance updated!!!')

    def go_to_bank_settings(self):
        self.settingd_stacked_widget.setCurrentIndex(2)
        self.payment_method_combo_box.setCurrentText(config.payment_method)
        self.card_number_edit.setText(config.card_number)

    def go_to_terms_and_conditions(self):
        self.settingd_stacked_widget.setCurrentIndex(3)

    def log_out(self):
        # Hide the current main window
        self.hide()
        print('Main window hidden')

        # Show the login app
        self.show_login_app()

    def show_login_app(self):
        print('Showing login app')

        # Ensure the login window is not created multiple times
        if hasattr(self, 'login_window') and self.login_window.isVisible():
            return  # Login window already open

        # Initialize and show the login window
        self.login_window = MainApp()  # Replace with your actual login window class
        self.login_window.show()
        MainApp.show_notification_message(self.login_window, 'Logged out successfully')

        # Optionally, if you need to close the current window, use self.close() instead of self.hide()
        # self.close()

    def go_to_malls_page(self):
        self.fetch_malls_data()
        self.home_page_widget.setCurrentIndex(0)

    def go_to_products_page(self):
        self.home_page_widget.setCurrentIndex(2)

        # Add malls data dictionary

    @staticmethod
    def fetch_malls_data():
        malls_data = []
        my_cur.execute(
            "SELECT mall_id, mall_name, mall_address, mall_owner, mall_logo FROM malls")
        for mall_id, mall_name, mall_address, mall_owner, mall_logo in my_cur.fetchall():
            # Fetch products for each mall
            my_cur.execute(
                "SELECT product_name, product_image, product_price, quantity_in_stock, description FROM products WHERE mall_id = %s",
                (mall_id,))
            products = [{"name": row[0], "image": row[1], "price": row[2], "quantity": row[3],
                         "description": row[4]}
                        for row in my_cur.fetchall()]
            malls_data.append({
                "id": mall_id,
                "name": mall_name,
                "address": mall_address,
                "owner": mall_owner,
                "logo": mall_logo,
                "products": products
            })
        return malls_data

    @staticmethod
    def fetch_products(mall_id):
        my_cur.execute(
            "SELECT product_name, product_image, product_price, quantity_in_stock, description, product_id, mall_id FROM products WHERE mall_id = %s",
            (mall_id,))
        products = my_cur.fetchall()
        return [
            {"name": row[0], "image": row[1], "price": row[2], "quantity": row[3], "description": row[4],
             "id": row[5], "mall_id": row[6]}
            for row in products]

    def populate_grid_layout_2(self, mall_id):
        self.clear_grid_layout_2()  # Clear the grid before populating it

        products_data = self.fetch_products(mall_id)
        print(f"Fetched products data: {products_data}")
        config.products = products_data

        for i, product in enumerate(products_data):
            image_label = ClickableLabel()
            image_label.setPixmap(
                QtGui.QPixmap(product['image']).scaled(100, 100, QtCore.Qt.AspectRatioMode.KeepAspectRatio)
            )
            name_label = ClickableLabel(product['name'])
            name_label.setAlignment(QtCore.Qt.AlignmentFlag.AlignCenter)

            image_label.clicked.connect(lambda p=product: self.show_product_details(p))
            name_label.clicked.connect(lambda p=product: self.show_product_details(p))

            add_to_cart_button_second = QPushButton("Add to Cart")
            add_to_cart_button_second.clicked.connect(lambda _, p=product: self.add_to_cart_second(p, p.get('mall_id')))
            disconnect_button_signals(self.add_to_cart_button)
            self.add_to_cart_button.clicked.connect(
                lambda: self.add_to_cart(self.current_product, self.current_product.get('mall_id')))

            row = i // 3
            col = i % 3

            self.gridLayout_2.addWidget(image_label, row * 3, col)
            self.gridLayout_2.addWidget(name_label, row * 3 + 1, col)
            self.gridLayout_2.addWidget(add_to_cart_button_second, row * 3 + 2, col)

    def add_to_cart(self, product, mall_id):
        # Ensure cart_items attribute exists
        if not hasattr(self, 'cart_items'):
            self.cart_items = []

        # Get the quantity from the input field
        quantity = self.quantity_edit.text()

        if quantity.isdigit() and int(quantity) > 0:
            quantity = int(quantity)

            # Add quantity and mall_id to the product dictionary
            product_with_details = product.copy()
            product_with_details['quantity'] = quantity
            product_with_details['mall_id'] = mall_id  # Add mall_id to the product details

            # Add the product with details to the cart
            self.cart_items.append(product_with_details)

            # Update the shopping cart frame
            self.update_shopping_cart_frame()

            # Update notification
            self.count += 1
            self.notification_label.setText(str(self.count))
            self.notification_label.show()

            # Determine the correct product name
            product_name = product.get('name', 'Product')  # Default to 'Product' if name is missing
            if quantity == 1:
                notification_message = f'{quantity} {product_name} added to cart'
            else:
                notification_message = f'{quantity} {product_name}s added to cart'

            self.show_notification_message(notification_message)
        else:
            # Handle invalid quantity input (e.g., show a message to the user)
            self.show_notification_message("Invalid quantity entered.")
            print("Invalid quantity entered.")

    def add_to_cart_second(self, product, mall_id):

        config.product_stock_quantity = product['quantity']
        print(config.product_stock_quantity)

        # Ensure cart_items attribute exists
        if not hasattr(self, 'cart_items'):
            self.cart_items = []

        # Get the quantity from the input field
        quantity = '1'

        if quantity.isdigit() and int(quantity) > 0:
            # Add quantity to the product dictionary

            product_with_quantity = product.copy()
            product_with_quantity['quantity'] = int(quantity)
            product_with_quantity['mall_id'] = mall_id

            # Add the product with quantity to the cart
            self.cart_items.append(product_with_quantity)

            # Update the shopping cart frame
            self.update_shopping_cart_frame()

            self.count += 1
            self.notification_label.setText(str(self.count))
            self.notification_label.show()
        else:
            # Handle invalid quantity input (e.g., show a message to the user)
            print("Invalid quantity entered.")

    def show_product_details(self, product):
        self.current_product = product

        self.home_page_widget.setCurrentIndex(3)
        self.product_image_label.setPixmap(
            QtGui.QPixmap(product['image']).scaled(100, 100, QtCore.Qt.AspectRatioMode.KeepAspectRatio))
        self.product_name_label.setText(product['name'])
        self.product_price_label.setText(f"${product['price']}")
        self.quantity_edit.setText('1')
        self.product_stock_quantity_label_.setText(str(product['quantity']))
        config.product_stock_quantity = product['quantity']
        self.product_description_label.setText(product['description'])

    def clear_grid_layout_2(self):
        while self.gridLayout_2.count():
            child = self.gridLayout_2.takeAt(0)
            if child.widget():
                child.widget().deleteLater()

    def update_product_details(self, product):
        self.product_name_label.setText(product['name'])
        self.product_image_label.setPixmap(
            QtGui.QPixmap(product['image']).scaled(200, 200, QtCore.Qt.AspectRatioMode.KeepAspectRatio))
        self.product_description_label.setText(product['description'])
        # self.product_price_label.setText(f"Price: ${product['price']}")
        self.product_stock_quantity_label_.setText(product['quantity'])

    def clear_cart(self):
        self.cart_items = []
        self.notification_label.hide()
        self.count = 0
        self.update_shopping_cart_frame()
        self.show_notification_message('Cart cleared successfully')

    def update_shopping_cart_frame(self):
        # Clear the layouts first
        def clear_layout(layout):
            while layout.count():
                item = layout.takeAt(0)
                if item is not None:
                    widget = item.widget()
                    if widget is not None:
                        widget.deleteLater()
                    else:
                        # If the item is a layout, clear its widgets
                        sub_layout = item.layout()
                        if sub_layout is not None:
                            while sub_layout.count():
                                sub_item = sub_layout.takeAt(0)
                                if sub_item.widget():
                                    sub_item.widget().deleteLater()
                            sub_layout.deleteLater()

        clear_layout(self.gridLayout_5)
        clear_layout(self.gridLayout_6)
        clear_layout(self.gridLayout_7)

        total_price = 0
        row = 0
        for product in self.cart_items:
            name_label = QLabel(f"{product['name']}")
            name_label.setStyleSheet("color: white;")

            price_label = QLabel(f"${product['price']}")
            price_label.setStyleSheet("color: white;")

            quantity_label = QLabel(f"{product['quantity']}")
            quantity_label.setStyleSheet("color: white;")
            config.product_quantity = int(product['quantity'])

            self.gridLayout_5.addWidget(name_label, row, 0, alignment=Qt.AlignmentFlag.AlignTop)
            self.gridLayout_6.addWidget(price_label, row, 0, alignment=Qt.AlignmentFlag.AlignTop)
            self.gridLayout_7.addWidget(quantity_label, row, 0, alignment=Qt.AlignmentFlag.AlignTop)

            total_price += int(product['price']) * int(product['quantity'])
            row += 1

        self.total_price_label.setText(str(total_price))

    def clear_grid_layout(self):
        while self.gridLayout.count():
            item = self.gridLayout.takeAt(0)
            widget = item.widget()
            if widget:
                widget.deleteLater()

    def populate_grid_layout(self):
        self.clear_grid_layout()  # Clear the grid before populating it

        malls_data = self.fetch_malls_data()
        print(f"Fetched malls data: {malls_data}")

        for i, mall in enumerate(malls_data):
            mall_name = mall["name"]
            mall_image = mall["logo"]

            # Create a frame for each mall
            mall_frame = QFrame(self.frame)
            mall_frame.setStyleSheet("background-color: none; border: 1px solid black;")
            mall_frame.setFixedSize(200, 200)  # Adjust the size as needed

            # Access existing labels by object name
            image_label = QLabel(mall_frame)
            image_label.setObjectName('main_image_label')
            name_label = QLabel(mall_frame)
            name_label.setObjectName('main_name_label')

            # Update image and text
            image_label.setPixmap(
                QtGui.QPixmap(mall_image).scaled(160, 160, QtCore.Qt.AspectRatioMode.KeepAspectRatio))
            image_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
            name_label.setText(mall_name)
            name_label.setAlignment(Qt.AlignmentFlag.AlignCenter)

            # Make the labels clickable
            image_label.setCursor(Qt.CursorShape.PointingHandCursor)
            name_label.setCursor(Qt.CursorShape.PointingHandCursor)
            image_label.mousePressEvent = lambda event, mall=mall: self.go_to_mall(mall)
            name_label.mousePressEvent = lambda event, mall=mall: self.go_to_mall(mall)

            # Layout for the mall frame
            mall_layout = QGridLayout(mall_frame)
            mall_layout.addWidget(image_label, 0, 0)
            mall_layout.addWidget(name_label, 1, 0)
            mall_frame.setLayout(mall_layout)

            # Add the mall frame to the main grid layout
            row = i // 3
            col = i % 3
            self.gridLayout.addWidget(mall_frame, row, col)

    def update_grid_layout(self):
        # Clear the existing layout
        while self.gridLayout.count():
            child = self.gridLayout.takeAt(0)
            if child.widget():
                child.widget().deleteLater()

        # Repopulate the grid layout with the latest data
        self.populate_grid_layout()

    def go_to_mall(self, mall):
        print(f"Selected Mall: {mall['name']}")
        add_visit(config.user_id, mall['id'])
        config.mall_id = mall['id']
        self.home_page_widget.setCurrentIndex(2)
        self.mall_name_label_products.setText(mall['name'])
        self.populate_grid_layout_2(mall['id'])

    def clear_inputs_1(self):
        self.mall_name_edit.clear()
        self.mall_address_edit.clear()
        self.mall_logo_edit.clear()

    def buy_products(self):
        # Validate that quantities in the cart do not exceed available stock
        for product in self.cart_items:
            product_id = product['id']
            requested_quantity = product['quantity']

            # Check if the requested quantity is greater than the available stock
            if requested_quantity > config.product_stock_quantity:
                print(config.product_stock_quantity)
                self.show_notification_message(
                    f"Cannot purchase {product['name']}. Requested quantity exceeds available stock.")
                print(f"Error: Cannot purchase {product['name']}. Requested quantity exceeds available stock.")
                return  # Exit the method if an error is found

        # Calculate the total price of the products in the cart
        total_price = sum(product['price'] * product['quantity'] for product in self.cart_items)

        try:
            # Check if the account balance is sufficient
            if total_price > config.account_balance:
                self.show_notification_message(
                    f"Error: Insufficient balance, you are ${total_price - config.account_balance}short")
                raise ValueError("Insufficient balance")

            # Subtract the total price from the account balance
            config.account_balance -= total_price
            load_time = 300 * len(self.cart_items)
            print(f'load time: {load_time}')

            self.loading_label.show()
            simulate_loading_label(self.loading_label, final_text="All done!", load_time=load_time, interval=200,
                                   loading_message='Processing', max_dots=3)

            # Iterate over the cart items and add each purchase
            for product in self.cart_items:

                product_id = product['id']
                product_quantity = product['quantity']
                product_stock_quantity = config.product_stock_quantity
                product_mall_id = product['mall_id']
                print(product_stock_quantity)

                # Add the purchase
                add_purchase(config.user_id, product_id, product_quantity,
                             product['price'] * product_quantity, config.payment_method, product_mall_id)

                calculate_and_store_conversion_rate(product_mall_id)

                # Update stock quantity
                product_stock_quantity -= product_quantity
                update_product_stock(product_id, product_stock_quantity, config.mall_id)
                print(product_stock_quantity)

                # Update the product's stock quantity label
                self.product_stock_quantity_label_.setText(str(product_stock_quantity))

            # Clear the cart after purchase
            self.cart_items = []
            self.notification_label.hide()
            self.count = 0
            self.update_shopping_cart_frame()

            # Update the account balance label
            update_account_balance(config.account_balance, config.user_id)
            self.account_balance_label.setText(f"{config.account_balance:.2f}")

            # Show a success message
            self.show_notification_message('Your Purchase was successful')
            print("Purchase Successful! The purchase was successful!")

        except ValueError as e:
            print(f"Error: {e}")

    def initialize_app(self):
        # Fetch data and set label texts
        self.initialize_labels()
        self.dashboard_button.clicked.connect(self.go_to_dashboard_page)
        self.profile_button_2.clicked.connect(self.go_to_products_page_seller)
        self.settings_button_2.clicked.connect(self.go_to_settings_page_seller)
        self.savechangesbuttonseller_2.clicked.connect(self.go_to_create_product_page)
        self.back_to_products_page_button_2.clicked.connect(self.go_to_products_page_seller)
        self.back_to_products_page_button_3.clicked.connect(self.go_to_products_page_seller)
        self.create_store_submit_button_2.clicked.connect(self.create_new_product)
        self.profile_settingsbutton_2.clicked.connect(self.go_to_profile_settings_seller)
        self.bank_settingsbutton_2.clicked.connect(self.go_to_bank_settings_seller)
        self.tandc_settingsbutton_2.clicked.connect(self.go_to_terms_and_conditions_seller)
        self.back_to_settings_page_button_4.clicked.connect(self.go_to_settings_page_seller)
        self.back_to_settings_page_button_5.clicked.connect(self.go_to_settings_page_seller)
        self.back_to_settings_page_button_6.clicked.connect(self.go_to_settings_page_seller)
        # Convert QLabel to ClickableLabel
        self.convert_labels_to_clickable()

        # Initialize chart with default data or settings
        self.update_chart('total_store_visits')  # or any default metric

    def initialize_labels(self):
        self.main_app_notif_label.setGeometry(QRect(230, -30, 360, 30))
        self.average_order_value_label.setFixedSize(150, 50)
        self.welcome_username_label.setText(f'Welcome, {config.username}!')
        data = fetch_all_data()
        top_products = get_top_products_details(config.mall_id) or []

        # Handle first product
        if len(top_products) > 0 and top_products[0]:
            first_product = top_products[0]
            self.main_image_label_1.setPixmap(QtGui.QPixmap(first_product[0]))
            self.product_name_label_1.setText(first_product[1])
            self.product_price_label_1.setText(str(first_product[2]))
            self.product_quantity_sold_label_1.setText(f'{first_product[3]} sold')
        else:
            self.main_image_label_1.clear()
            self.product_name_label_1.setText("N/A")
            self.product_price_label_1.setText("N/A")
            self.product_quantity_sold_label_1.setText("N/A")

        # Handle second product
        if len(top_products) > 1 and top_products[1]:
            second_product = top_products[1]
            self.main_image_label_2.setPixmap(QtGui.QPixmap(second_product[0]))
            self.product_name_label_2.setText(second_product[1])
            self.product_price_label_2.setText(str(second_product[2]))
            self.product_quantity_sold_label_2.setText(f'{second_product[3]} sold')
        else:
            self.main_image_label_2.clear()
            self.product_name_label_2.setText("N/A")
            self.product_price_label_2.setText("N/A")
            self.product_quantity_sold_label_2.setText("N/A")

        # Handle third product
        if len(top_products) > 2 and top_products[2]:
            third_product = top_products[2]
            self.main_image_label_3.setPixmap(QtGui.QPixmap(third_product[0]))
            self.product_name_label_3.setText(third_product[1])
            self.product_price_label_3.setText(str(third_product[2]))
            self.product_quantity_sold_label_3.setText(f'{third_product[3]} sold')
        else:
            self.main_image_label_3.clear()
            self.product_name_label_3.setText("N/A")
            self.product_price_label_3.setText("N/A")
            self.product_quantity_sold_label_3.setText("N/A")

        # Safely handle metric data
        average_order_value = data.get("average_order_value", 0)
        total_profit = data.get("total_profit", 0)
        total_order_items = data.get("total_order_items", 0)
        total_order_units = data.get("total_order_units", 0)
        total_store_visits = data.get("total_store_visits", 0)
        order_conversion_rate = data.get("order_conversion_rate", 0)
        print(f'gegegegeg {order_conversion_rate}')

        # Format the metrics with a fallback for None values
        self.average_order_value_label.setText(f'{average_order_value:.2f}' if average_order_value else 'N/A')
        self.total_profit_label.setText(f'{total_profit}' if total_profit else 'N/A')
        # self.total_profit_label.setGeometry(30, 0, 151, 51)
        self.total_order_items_label.setText(f'{total_order_items}' if total_order_items else 'N/A')
        self.total_order_units_label.setText(f'{total_order_units}' if total_order_units else 'N/A')
        self.total_store_visits_label.setText(f'{total_store_visits}' if total_store_visits else 'N/A')

        # Safely handle conversion of order_conversion_rate
        try:
            order_conversion_rate_value = float(order_conversion_rate) if order_conversion_rate else 0
        except (ValueError, TypeError):
            order_conversion_rate_value = 0

        self.order_conversion_rate_label.setText(f'{order_conversion_rate_value:.2f}')
        print(order_conversion_rate_value)

        # Handle layout adjustment for order conversion rate
        if order_conversion_rate_value >= 100:
            self.order_conversion_rate_label.setGeometry(220, 210, 151, 55)
            self.total_amount_spent_label_4.setGeometry(360, 210, 41, 51)

    def go_to_dashboard_page(self):
        self.stackedWidget.setCurrentIndex(0)

    def go_to_products_page_seller(self):
        self.stackedWidget.setCurrentIndex(1)
        self.products_stackd_widget.setCurrentIndex(0)
        self.populate_products()

    def go_to_settings_page_seller(self):
        self.stackedWidget.setCurrentIndex(2)
        self.seller_settings_stacked_widget.setCurrentIndex(0)

    def go_to_create_product_page(self):
        self.products_stackd_widget.setCurrentIndex(2)

    def update_chart(self, metric):
        # Clear the previous series
        layout = QVBoxLayout(self.chart_frame)
        layout.setContentsMargins(0, 0, 10, 10)  # Set margins (left, top, right, bottom)
        # layout.setSpacing(10)  # Set spacing between widgets
        layout.addWidget(self.chart_view)
        self.chart_view.setFixedSize(630, 300)  # Width x Height in pixels
        self.chart.removeAllSeries()

        # Clear the previous axes
        for axis in self.chart.axes():
            self.chart.removeAxis(axis)

        # Fetch new data
        data = fetch_data(metric)

        # Create a new series
        series = QLineSeries()
        for point in data:
            series.append(point[0], point[1])  # Adjust based on your data structure

        self.chart.addSeries(series)

        # Create custom X and Y axes
        x_axis = QValueAxis()
        y_axis = QValueAxis()

        # Set axis ranges
        if data:
            x_axis.setRange(0, len(data) - 1)  # Adjust range based on data length
            y_axis.setRange(min(point[1] for point in data) * 0.9,
                            max(point[1] for point in data) * 1.1)  # Adjust y-axis range based on data
        else:
            x_axis.setRange(0, 1)  # Default range
            y_axis.setRange(0, 1)  # Default range

        x_axis.setLabelFormat('%d')
        y_axis.setLabelFormat('%d')
        x_axis.setTitleText('Time Period')
        y_axis.setTitleText('Value')

        # Add custom axes to the chart
        self.chart.addAxis(x_axis, Qt.AlignmentFlag.AlignBottom)
        self.chart.addAxis(y_axis, Qt.AlignmentFlag.AlignLeft)

        # Set the axis for the series
        series.attachAxis(x_axis)
        series.attachAxis(y_axis)

        # Update the chart view
        self.chart_view.repaint()

    def clear_grid_layout_seller(self):
        while self.gridLayout.count():
            item = self.gridLayout.takeAt(0)
            widget = item.widget()
            if widget:
                widget.deleteLater()

    def populate_products(self):
        try:
            self.clear_grid_layout_seller()  # Clear the grid before populating it
            products_list = fetch_all_products(config.mall_id)
            print(products_list)

            # Iterate over your product list and create a new frame for each product
            for i, product in enumerate(products_list):
                # Create a new frame for each product
                product_frame = QFrame(self)
                product_frame.setStyleSheet("border: 1px solid black;")  # Optional: Add border to frame
                product_frame.setFixedSize(200, 250)  # Adjust the size as needed

                # Create and configure the labels directly
                image_label = QLabel(product_frame)
                image_label.setPixmap(QtGui.QPixmap(product['product_image']).scaled(100, 100))  # Scale image as needed
                image_label.setGeometry(40, 10, 100, 100)  # Position the image inside the frame

                name_label = QLabel(product_frame)
                name_label.setText(product['product_name'])
                name_label.setGeometry(10, 120, 180, 20)  # Position the name label

                price_label = QLabel(product_frame)
                price_label.setText(f"${product['product_price']:.2f}")
                price_label.setGeometry(10, 140, 180, 20)  # Position the price label

                quantity_label = QLabel(product_frame)
                quantity_label.setText(f"Quantity: {product['quantity_in_stock']}")
                quantity_label.setGeometry(10, 160, 180, 20)  # Position the quantity label

                # Create the button with text '...'
                details_button = QPushButton('...', product_frame)
                details_button.setGeometry(75, 200, 30, 20)  # Position the button within the frame
                details_button.setStyleSheet("""
                    QPushButton {
                        background-color: none;
                        border-radius: 5px;
                    }
                    QPushButton:hover {
                        background-color: darkgray;
                    }
                """)  # Set the button's style and hover effect

                # Connect the button click to a method (you can implement this method to navigate to the details page)
                details_button.clicked.connect(lambda _, p=product: self.show_product_details_seller(p))

                # Add the product frame to the grid layout
                row = i // 2
                column = i % 2
                self.gridLayout_3.addWidget(product_frame, row, column)
        except Exception as e:
            print(f'error: {e}')
            traceback.print_exc()  # This will print a full stack trace

    def show_product_details_seller(self, product):
        # Navigate to the product details page
        self.products_stackd_widget.setCurrentIndex(1)

        print(f"Showing details for: {product['product_name']}")

        # Set product details to config
        config.product_id = product['product_id']
        config.product_name = product['product_name']
        config.product_image = product['product_image']
        config.product_price = product['product_price']
        config.product_stock = product['quantity_in_stock']
        config.product_description = product['description']

        # Update the UI with the product details
        self.product_image_label_2.setPixmap(QtGui.QPixmap(product['product_image']).scaled(100, 100))  # Scale image
        self.productnamelineedit.setText(product['product_name'])
        self.productpricelineedit.setText(str(product['product_price']))
        self.quantitystocklineedit.setText(str(product['quantity_in_stock']))
        self.productdescriptioedit.setText(product['description'])

        # Connect the save changes button to the save method
        self.savechangesbuttonseller.clicked.connect(self.save_product_info_changes)
        self.deleteproductbutton.clicked.connect(self.handle_product_delete)

    def save_product_info_changes(self):
        try:
            product_name = self.productnamelineedit.text()
            product_price = self.productpricelineedit.text()
            product_quantity = self.quantitystocklineedit.text()
            product_description = self.productdescriptioedit.toPlainText()
            print(config.mall_id)

            update_product_info(config.product_id, product_name, float(product_price), int(product_quantity),
                                product_description, config.mall_id)

            self.show_notification_message('product info updated')

        except Exception as e:
            print(f'error: {e}')
            traceback.print_exc()

    def delete_product(self, product_id, mall_id):
        # Delete product from the products table
        delete_product_query = """
                    DELETE FROM products WHERE product_id = %s
                    """
        my_cur.execute(delete_product_query, (product_id,))

        # Step 2: Fetch the mall's mall_products JSON data
        fetch_mall_products_query = """
                    SELECT mall_products FROM malls WHERE mall_id = %s
                    """
        my_cur.execute(fetch_mall_products_query, (mall_id,))
        result = my_cur.fetchone()

        if result:
            mall_products_json = result[0]
            print(f'{mall_products_json}')

            # Step 3: Deserialize the JSON data
            mall_products = json.loads(mall_products_json)

            # Step 4: Find and remove the product from the JSON list
            updated_mall_products = [product for product in mall_products if product['product_id'] != product_id]

            # Step 5: Serialize the updated JSON data back to a string
            updated_mall_products_json = json.dumps(updated_mall_products)
            print(f'{updated_mall_products_json}')

            # Step 6: Update the malls table with the new mall_products JSON
            update_mall_products_query = """
                        UPDATE malls
                        SET mall_products = %s
                        WHERE mall_id = %s
                        """
            my_cur.execute(update_mall_products_query, (updated_mall_products_json, mall_id))
            conn_obj.commit()
            self.show_notification_message(f'product {config.product_name} deleted successfully')
            self.products_stackd_widget.setCurrentIndex(0)
            self.populate_products()

    def handle_product_delete(self):
        try:
            self.delete_product(config.product_id, config.mall_id)
        except Exception as e:
            print(f'error: {e}')
            traceback.print_exc()

    def create_new_product(self):
        # Step 1: Retrieve the input values
        product_image = self.mall_logo_edit_2.text().strip()
        product_name = self.mall_name_edit_2.text().strip()
        product_price = self.mall_address_edit_2.text().strip()
        product_description = self.textEdit_2.toPlainText().strip()

        # Step 2: Validate the inputs
        # Check if product name is provided
        if not product_name:
            self.show_notification_message("Product name is required.")
            return

        # Check if product price is provided and is a valid number
        try:
            product_price = float(product_price)
            if product_price <= 0:
                self.show_notification_message("Product price must be greater than zero.")
                return
        except ValueError:
            self.show_notification_message("Invalid price. Please enter a valid number.")
            return

        # Check if product description is provided
        if not product_description:
            self.show_notification_message("Product description is required.")
            return

        # Check if product image is provided (optional, depending on your requirements)
        if not product_image:
            self.show_notification_message("Product image path is required.")
            return

        # Step 3: Call the create_new_product function with validated inputs
        try:
            create_new_product(product_name, product_price, product_description, product_image, config.mall_id)
            self.show_notification_message(f"Product '{product_name}' created successfully.")
            self.products_stackd_widget.setCurrentIndex(0)
            self.populate_products()
        except Exception as e:
            self.show_notification_message(f"Failed to create product: {str(e)}")

        self.mall_logo_edit_2.clear()
        self.mall_name_edit_2.clear()
        self.mall_address_edit_2.clear()
        self.textEdit_2.clear()

    def convert_labels_to_clickable(self):

        self.averageordervaluebutton.clicked.connect(lambda: self.on_label_clicked('average_order_value'))
        self.totalprofitbutton.clicked.connect(lambda: self.on_label_clicked('total_profit'))
        self.totalorderitemsbutton.clicked.connect(lambda: self.on_label_clicked('total_order_items'))
        self.totalorderunitsbutton.clicked.connect(lambda: self.on_label_clicked('total_order_units'))
        self.totalstorevisistsbutton.clicked.connect(lambda: self.on_label_clicked('total_store_visits'))
        self.orderconversionratebutton.clicked.connect(lambda: self.on_label_clicked('order_conversion_rate'))

    def on_label_clicked(self, metric):
        print(f"Label clicked: {metric}")  # Debugging line
        self.update_chart(metric)

    def go_to_profile_settings_seller(self):
        self.seller_settings_stacked_widget.setCurrentIndex(1)
        self.profilesetting_username_line_edit_2.setText(config.username)
        self.profilesettings_email_line_edit_2.setText(config.email)
        self.profile_uid_label_3.setText(config.user_id)
        self.profile_uid_label_4.setText(config.gov_id)
        self.profile_picture_label_3.setPixmap(QtGui.QPixmap("./images/accounticonpng.png"))
        self.save_changes_button_2.clicked.connect(self.save_changes_seller)

    def save_changes_seller(self):
        username = self.profilesetting_username_line_edit_2.text()
        email = self.profilesettings_email_line_edit_2.text()
        user_id = config.user_id

        update_account_info(username, email, user_id)
        self.show_notification_message('Account info updated')

    def save_bank_info_changes_seller(self):
        bank_name = self.bank_name_combo_box.currentText()
        config.bank_name = bank_name
        account_number = self.account_number_edit.text()

        if not account_number.isdigit():
            self.show_notification_message('new account number is not numbers')
            print('new account number is not numbers')
            return

        if not len(account_number) == 10:
            self.show_notification_message('incomplete account number')
            print('incomplete account number')

        config.bank_acct_number = account_number
        self.show_notification_message('Bank info updated')
        print('Bank info updated')

    def withdraw_money(self):
        amount = self.withdraw_money_line_edit.text()

        if float(amount) > config.account_balance:
            self.show_notification_message('exceeds account balance')
            print('exceeds account balance')
            return

        if not amount.isdigit():
            self.show_notification_message('incorrect input')
            print('incorrect input')
            return

        if len(amount) > 8:
            self.show_notification_message('invalid amount')
            print('invalid amount')
            return

        new_balance = config.account_balance - int(amount)
        user_id = config.mall_id.replace(config.mall_id[0], '')
        update_account_balance(new_balance, user_id)
        config.account_balance = new_balance
        self.account_balance_label_2.setText(str(new_balance))
        self.show_notification_message(f'${amount} withdrawn successfully!!!')
        self.withdraw_money_line_edit.clear()
        print(f'${amount} withdrawn successfully!!!')

    def go_to_bank_settings_seller(self):
        self.seller_settings_stacked_widget.setCurrentIndex(2)
        self.bank_name_combo_box.setCurrentText(config.bank_name)
        self.account_name_edit.setText(config.full_name)
        self.account_number_edit.setText(config.bank_acct_number)
        print(f'gery {config.bank_acct_number}')

    def go_to_terms_and_conditions_seller(self):
        self.seller_settings_stacked_widget.setCurrentIndex(3)

    def handle_create_mall(self):
        mall_name = self.mall_name_edit.text()
        mall_address = self.mall_address_edit.text()
        mall_owner = config.user_id
        mall_logo = self.mall_logo_edit.text()

        if not mall_name:
            self.show_notification_message('input a mall name')
            print('Input a mall name')
            return

        if not is_valid_mall_name(mall_name):
            self.show_notification_message(f'mall name {mall_name} already exists')
            return

        is_valid, message = validate_address(mall_address)

        if not is_valid:
            self.show_notification_message(message)
            return

        if not validate_user_id(mall_owner):
            print(mall_owner)
            self.show_notification_message('user doesnt exist')
            return

        if not mall_logo:
            self.show_notification_message('please input a logo path for your mall')
            return

        mall_id = create_mall_id(mall_owner)

        mall = create_mall(mall_name, mall_address, mall_id, mall_owner, mall_logo)

        if mall:
            self.show_notification_message('mall created successfully')
            simulate_loading('Mall created successfully')
            self.clear_inputs_mall()
            self.app_stacked_widget.setCurrentIndex(0)
            self.sign_in_page.setCurrentIndex(0)
        else:
            print("Failed to create a mall.")

    def clear_inputs_mall(self):
        self.mall_name_edit.clear()
        self.mall_address_edit.clear()
        self.mall_logo_edit.clear()



if __name__ == "__main__":
    app = QApplication([])
    window = MainApp()
    window.show()
    app.exec()
